/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  addDecoderSizePrefix,
  addEncoderSizePrefix,
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  getU32Decoder,
  getU32Encoder,
  getUtf8Decoder,
  getUtf8Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type Option,
  type OptionOrNullable,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from "@solana/kit";
import { POLICY_CHALLENGES_PROGRAM_ADDRESS } from "../programs";
import {
  expectSome,
  getAccountMetaFactory,
  type ResolvedAccount,
} from "../shared";
import {
  getChallengeInsertDtoDecoder,
  getChallengeInsertDtoEncoder,
  getChallengeUpdateDtoDecoder,
  getChallengeUpdateDtoEncoder,
  type ChallengeInsertDto,
  type ChallengeInsertDtoArgs,
  type ChallengeUpdateDto,
  type ChallengeUpdateDtoArgs,
} from "../types";

export const ORACLE_CREATE_OR_UPDATE_CHALLENGE_DISCRIMINATOR = new Uint8Array([
  31, 218, 143, 189, 30, 97, 201, 49,
]);

export function getOracleCreateOrUpdateChallengeDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    ORACLE_CREATE_OR_UPDATE_CHALLENGE_DISCRIMINATOR,
  );
}

export type OracleCreateOrUpdateChallengeInstruction<
  TProgram extends string = typeof POLICY_CHALLENGES_PROGRAM_ADDRESS,
  TAccountChallengeTemplateAccount extends string | AccountMeta<string> =
    string,
  TAccountChallengeAccount extends string | AccountMeta<string> = string,
  TAccountOracle extends string | AccountMeta<string> = string,
  TAccountSystemProgram extends string | AccountMeta<string> =
    "11111111111111111111111111111111",
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountChallengeTemplateAccount extends string
        ? WritableAccount<TAccountChallengeTemplateAccount>
        : TAccountChallengeTemplateAccount,
      TAccountChallengeAccount extends string
        ? WritableAccount<TAccountChallengeAccount>
        : TAccountChallengeAccount,
      TAccountOracle extends string
        ? WritableSignerAccount<TAccountOracle> &
            AccountSignerMeta<TAccountOracle>
        : TAccountOracle,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      ...TRemainingAccounts,
    ]
  >;

export type OracleCreateOrUpdateChallengeInstructionData = {
  discriminator: ReadonlyUint8Array;
  challengeId: string;
  user: Address;
  insertDto: Option<ChallengeInsertDto>;
  updateDto: ChallengeUpdateDto;
};

export type OracleCreateOrUpdateChallengeInstructionDataArgs = {
  challengeId: string;
  user: Address;
  insertDto: OptionOrNullable<ChallengeInsertDtoArgs>;
  updateDto: ChallengeUpdateDtoArgs;
};

export function getOracleCreateOrUpdateChallengeInstructionDataEncoder(): Encoder<OracleCreateOrUpdateChallengeInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["challengeId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
      ["user", getAddressEncoder()],
      ["insertDto", getOptionEncoder(getChallengeInsertDtoEncoder())],
      ["updateDto", getChallengeUpdateDtoEncoder()],
    ]),
    (value) => ({
      ...value,
      discriminator: ORACLE_CREATE_OR_UPDATE_CHALLENGE_DISCRIMINATOR,
    }),
  );
}

export function getOracleCreateOrUpdateChallengeInstructionDataDecoder(): Decoder<OracleCreateOrUpdateChallengeInstructionData> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["challengeId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["user", getAddressDecoder()],
    ["insertDto", getOptionDecoder(getChallengeInsertDtoDecoder())],
    ["updateDto", getChallengeUpdateDtoDecoder()],
  ]);
}

export function getOracleCreateOrUpdateChallengeInstructionDataCodec(): Codec<
  OracleCreateOrUpdateChallengeInstructionDataArgs,
  OracleCreateOrUpdateChallengeInstructionData
> {
  return combineCodec(
    getOracleCreateOrUpdateChallengeInstructionDataEncoder(),
    getOracleCreateOrUpdateChallengeInstructionDataDecoder(),
  );
}

export type OracleCreateOrUpdateChallengeAsyncInput<
  TAccountChallengeTemplateAccount extends string = string,
  TAccountChallengeAccount extends string = string,
  TAccountOracle extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  challengeTemplateAccount: Address<TAccountChallengeTemplateAccount>;
  /** Challenge account - will be initialized if it doesn't exist */
  challengeAccount?: Address<TAccountChallengeAccount>;
  oracle: TransactionSigner<TAccountOracle>;
  systemProgram?: Address<TAccountSystemProgram>;
  challengeId: OracleCreateOrUpdateChallengeInstructionDataArgs["challengeId"];
  user: OracleCreateOrUpdateChallengeInstructionDataArgs["user"];
  insertDto: OracleCreateOrUpdateChallengeInstructionDataArgs["insertDto"];
  updateDto: OracleCreateOrUpdateChallengeInstructionDataArgs["updateDto"];
};

export async function getOracleCreateOrUpdateChallengeInstructionAsync<
  TAccountChallengeTemplateAccount extends string,
  TAccountChallengeAccount extends string,
  TAccountOracle extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof POLICY_CHALLENGES_PROGRAM_ADDRESS,
>(
  input: OracleCreateOrUpdateChallengeAsyncInput<
    TAccountChallengeTemplateAccount,
    TAccountChallengeAccount,
    TAccountOracle,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress },
): Promise<
  OracleCreateOrUpdateChallengeInstruction<
    TProgramAddress,
    TAccountChallengeTemplateAccount,
    TAccountChallengeAccount,
    TAccountOracle,
    TAccountSystemProgram
  >
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? POLICY_CHALLENGES_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    challengeTemplateAccount: {
      value: input.challengeTemplateAccount ?? null,
      isWritable: true,
    },
    challengeAccount: {
      value: input.challengeAccount ?? null,
      isWritable: true,
    },
    oracle: { value: input.oracle ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.challengeAccount.value) {
    accounts.challengeAccount.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getAddressEncoder().encode(expectSome(args.user)),
        getUtf8Encoder().encode(expectSome(args.challengeId)),
      ],
    });
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      "11111111111111111111111111111111" as Address<"11111111111111111111111111111111">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.challengeTemplateAccount),
      getAccountMeta(accounts.challengeAccount),
      getAccountMeta(accounts.oracle),
      getAccountMeta(accounts.systemProgram),
    ],
    data: getOracleCreateOrUpdateChallengeInstructionDataEncoder().encode(
      args as OracleCreateOrUpdateChallengeInstructionDataArgs,
    ),
    programAddress,
  } as OracleCreateOrUpdateChallengeInstruction<
    TProgramAddress,
    TAccountChallengeTemplateAccount,
    TAccountChallengeAccount,
    TAccountOracle,
    TAccountSystemProgram
  >);
}

export type OracleCreateOrUpdateChallengeInput<
  TAccountChallengeTemplateAccount extends string = string,
  TAccountChallengeAccount extends string = string,
  TAccountOracle extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  challengeTemplateAccount: Address<TAccountChallengeTemplateAccount>;
  /** Challenge account - will be initialized if it doesn't exist */
  challengeAccount: Address<TAccountChallengeAccount>;
  oracle: TransactionSigner<TAccountOracle>;
  systemProgram?: Address<TAccountSystemProgram>;
  challengeId: OracleCreateOrUpdateChallengeInstructionDataArgs["challengeId"];
  user: OracleCreateOrUpdateChallengeInstructionDataArgs["user"];
  insertDto: OracleCreateOrUpdateChallengeInstructionDataArgs["insertDto"];
  updateDto: OracleCreateOrUpdateChallengeInstructionDataArgs["updateDto"];
};

export function getOracleCreateOrUpdateChallengeInstruction<
  TAccountChallengeTemplateAccount extends string,
  TAccountChallengeAccount extends string,
  TAccountOracle extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof POLICY_CHALLENGES_PROGRAM_ADDRESS,
>(
  input: OracleCreateOrUpdateChallengeInput<
    TAccountChallengeTemplateAccount,
    TAccountChallengeAccount,
    TAccountOracle,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress },
): OracleCreateOrUpdateChallengeInstruction<
  TProgramAddress,
  TAccountChallengeTemplateAccount,
  TAccountChallengeAccount,
  TAccountOracle,
  TAccountSystemProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? POLICY_CHALLENGES_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    challengeTemplateAccount: {
      value: input.challengeTemplateAccount ?? null,
      isWritable: true,
    },
    challengeAccount: {
      value: input.challengeAccount ?? null,
      isWritable: true,
    },
    oracle: { value: input.oracle ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      "11111111111111111111111111111111" as Address<"11111111111111111111111111111111">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.challengeTemplateAccount),
      getAccountMeta(accounts.challengeAccount),
      getAccountMeta(accounts.oracle),
      getAccountMeta(accounts.systemProgram),
    ],
    data: getOracleCreateOrUpdateChallengeInstructionDataEncoder().encode(
      args as OracleCreateOrUpdateChallengeInstructionDataArgs,
    ),
    programAddress,
  } as OracleCreateOrUpdateChallengeInstruction<
    TProgramAddress,
    TAccountChallengeTemplateAccount,
    TAccountChallengeAccount,
    TAccountOracle,
    TAccountSystemProgram
  >);
}

export type ParsedOracleCreateOrUpdateChallengeInstruction<
  TProgram extends string = typeof POLICY_CHALLENGES_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    challengeTemplateAccount: TAccountMetas[0];
    /** Challenge account - will be initialized if it doesn't exist */
    challengeAccount: TAccountMetas[1];
    oracle: TAccountMetas[2];
    systemProgram: TAccountMetas[3];
  };
  data: OracleCreateOrUpdateChallengeInstructionData;
};

export function parseOracleCreateOrUpdateChallengeInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedOracleCreateOrUpdateChallengeInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 4) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      challengeTemplateAccount: getNextAccount(),
      challengeAccount: getNextAccount(),
      oracle: getNextAccount(),
      systemProgram: getNextAccount(),
    },
    data: getOracleCreateOrUpdateChallengeInstructionDataDecoder().decode(
      instruction.data,
    ),
  };
}
