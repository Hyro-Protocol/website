/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertIsInstructionWithAccounts,
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type Instruction,
  type InstructionWithData,
  type ReadonlyUint8Array,
} from "@solana/kit";
import {
  parseClaimPayoutInstruction,
  parseCreateChallengeTemplateInstruction,
  parseJoinChallengeInstruction,
  parseOracleCreateChallengeInstruction,
  parseOracleCreateOrUpdateChallengeInstruction,
  parseUpdateChallengeInstruction,
  parseUpdateChallengeTemplateAdminInstruction,
  parseUpdateChallengeTemplateDailyDrawdownInstruction,
  parseUpdateChallengeTemplateEntranceCostInstruction,
  parseUpdateChallengeTemplateEntranceTokenMintInstruction,
  parseUpdateChallengeTemplateInstruction,
  parseUpdateChallengeTemplateIsActiveInstruction,
  parseUpdateChallengeTemplateMaximumLossInstruction,
  parseUpdateChallengeTemplateMaxParticipantsInstruction,
  parseUpdateChallengeTemplateMinimumTradingDaysInstruction,
  parseUpdateChallengeTemplateProfitTargetInstruction,
  parseValidateInstruction,
  type ParsedClaimPayoutInstruction,
  type ParsedCreateChallengeTemplateInstruction,
  type ParsedJoinChallengeInstruction,
  type ParsedOracleCreateChallengeInstruction,
  type ParsedOracleCreateOrUpdateChallengeInstruction,
  type ParsedUpdateChallengeInstruction,
  type ParsedUpdateChallengeTemplateAdminInstruction,
  type ParsedUpdateChallengeTemplateDailyDrawdownInstruction,
  type ParsedUpdateChallengeTemplateEntranceCostInstruction,
  type ParsedUpdateChallengeTemplateEntranceTokenMintInstruction,
  type ParsedUpdateChallengeTemplateInstruction,
  type ParsedUpdateChallengeTemplateIsActiveInstruction,
  type ParsedUpdateChallengeTemplateMaximumLossInstruction,
  type ParsedUpdateChallengeTemplateMaxParticipantsInstruction,
  type ParsedUpdateChallengeTemplateMinimumTradingDaysInstruction,
  type ParsedUpdateChallengeTemplateProfitTargetInstruction,
  type ParsedValidateInstruction,
} from "../instructions";

export const POLICY_CHALLENGES_PROGRAM_ADDRESS =
  "9GbrovAKnWfbXuq5dXYiZgZob75qTBz9HFcZGFRjftcH" as Address<"9GbrovAKnWfbXuq5dXYiZgZob75qTBz9HFcZGFRjftcH">;

export enum PolicyChallengesAccount {
  Challenge,
  ChallengeTemplate,
}

export function identifyPolicyChallengesAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): PolicyChallengesAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([119, 250, 161, 121, 119, 81, 22, 208]),
      ),
      0,
    )
  ) {
    return PolicyChallengesAccount.Challenge;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([83, 2, 108, 68, 110, 219, 175, 21]),
      ),
      0,
    )
  ) {
    return PolicyChallengesAccount.ChallengeTemplate;
  }
  throw new Error(
    "The provided account could not be identified as a policyChallenges account.",
  );
}

export enum PolicyChallengesInstruction {
  ClaimPayout,
  CreateChallengeTemplate,
  JoinChallenge,
  OracleCreateChallenge,
  OracleCreateOrUpdateChallenge,
  UpdateChallenge,
  UpdateChallengeTemplate,
  UpdateChallengeTemplateAdmin,
  UpdateChallengeTemplateDailyDrawdown,
  UpdateChallengeTemplateEntranceCost,
  UpdateChallengeTemplateEntranceTokenMint,
  UpdateChallengeTemplateIsActive,
  UpdateChallengeTemplateMaxParticipants,
  UpdateChallengeTemplateMaximumLoss,
  UpdateChallengeTemplateMinimumTradingDays,
  UpdateChallengeTemplateProfitTarget,
  Validate,
}

export function identifyPolicyChallengesInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): PolicyChallengesInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([127, 240, 132, 62, 227, 198, 146, 133]),
      ),
      0,
    )
  ) {
    return PolicyChallengesInstruction.ClaimPayout;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([143, 77, 148, 223, 18, 207, 212, 41]),
      ),
      0,
    )
  ) {
    return PolicyChallengesInstruction.CreateChallengeTemplate;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([41, 104, 214, 73, 32, 168, 76, 79]),
      ),
      0,
    )
  ) {
    return PolicyChallengesInstruction.JoinChallenge;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([160, 221, 250, 59, 178, 9, 237, 102]),
      ),
      0,
    )
  ) {
    return PolicyChallengesInstruction.OracleCreateChallenge;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([31, 218, 143, 189, 30, 97, 201, 49]),
      ),
      0,
    )
  ) {
    return PolicyChallengesInstruction.OracleCreateOrUpdateChallenge;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([189, 212, 76, 181, 2, 202, 238, 16]),
      ),
      0,
    )
  ) {
    return PolicyChallengesInstruction.UpdateChallenge;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([114, 162, 103, 83, 47, 148, 138, 174]),
      ),
      0,
    )
  ) {
    return PolicyChallengesInstruction.UpdateChallengeTemplate;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([81, 198, 17, 48, 33, 251, 104, 80]),
      ),
      0,
    )
  ) {
    return PolicyChallengesInstruction.UpdateChallengeTemplateAdmin;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([100, 174, 225, 136, 76, 206, 146, 63]),
      ),
      0,
    )
  ) {
    return PolicyChallengesInstruction.UpdateChallengeTemplateDailyDrawdown;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([7, 181, 39, 15, 22, 133, 159, 130]),
      ),
      0,
    )
  ) {
    return PolicyChallengesInstruction.UpdateChallengeTemplateEntranceCost;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([94, 23, 238, 69, 73, 130, 153, 89]),
      ),
      0,
    )
  ) {
    return PolicyChallengesInstruction.UpdateChallengeTemplateEntranceTokenMint;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([57, 176, 93, 106, 136, 216, 189, 142]),
      ),
      0,
    )
  ) {
    return PolicyChallengesInstruction.UpdateChallengeTemplateIsActive;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([86, 71, 53, 242, 216, 57, 184, 109]),
      ),
      0,
    )
  ) {
    return PolicyChallengesInstruction.UpdateChallengeTemplateMaxParticipants;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([111, 239, 61, 167, 113, 215, 92, 38]),
      ),
      0,
    )
  ) {
    return PolicyChallengesInstruction.UpdateChallengeTemplateMaximumLoss;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([67, 107, 22, 76, 9, 91, 83, 8]),
      ),
      0,
    )
  ) {
    return PolicyChallengesInstruction.UpdateChallengeTemplateMinimumTradingDays;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([64, 12, 173, 109, 35, 183, 191, 114]),
      ),
      0,
    )
  ) {
    return PolicyChallengesInstruction.UpdateChallengeTemplateProfitTarget;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([60, 252, 90, 66, 246, 253, 232, 139]),
      ),
      0,
    )
  ) {
    return PolicyChallengesInstruction.Validate;
  }
  throw new Error(
    "The provided instruction could not be identified as a policyChallenges instruction.",
  );
}

export type ParsedPolicyChallengesInstruction<
  TProgram extends string = "9GbrovAKnWfbXuq5dXYiZgZob75qTBz9HFcZGFRjftcH",
> =
  | ({
      instructionType: PolicyChallengesInstruction.ClaimPayout;
    } & ParsedClaimPayoutInstruction<TProgram>)
  | ({
      instructionType: PolicyChallengesInstruction.CreateChallengeTemplate;
    } & ParsedCreateChallengeTemplateInstruction<TProgram>)
  | ({
      instructionType: PolicyChallengesInstruction.JoinChallenge;
    } & ParsedJoinChallengeInstruction<TProgram>)
  | ({
      instructionType: PolicyChallengesInstruction.OracleCreateChallenge;
    } & ParsedOracleCreateChallengeInstruction<TProgram>)
  | ({
      instructionType: PolicyChallengesInstruction.OracleCreateOrUpdateChallenge;
    } & ParsedOracleCreateOrUpdateChallengeInstruction<TProgram>)
  | ({
      instructionType: PolicyChallengesInstruction.UpdateChallenge;
    } & ParsedUpdateChallengeInstruction<TProgram>)
  | ({
      instructionType: PolicyChallengesInstruction.UpdateChallengeTemplate;
    } & ParsedUpdateChallengeTemplateInstruction<TProgram>)
  | ({
      instructionType: PolicyChallengesInstruction.UpdateChallengeTemplateAdmin;
    } & ParsedUpdateChallengeTemplateAdminInstruction<TProgram>)
  | ({
      instructionType: PolicyChallengesInstruction.UpdateChallengeTemplateDailyDrawdown;
    } & ParsedUpdateChallengeTemplateDailyDrawdownInstruction<TProgram>)
  | ({
      instructionType: PolicyChallengesInstruction.UpdateChallengeTemplateEntranceCost;
    } & ParsedUpdateChallengeTemplateEntranceCostInstruction<TProgram>)
  | ({
      instructionType: PolicyChallengesInstruction.UpdateChallengeTemplateEntranceTokenMint;
    } & ParsedUpdateChallengeTemplateEntranceTokenMintInstruction<TProgram>)
  | ({
      instructionType: PolicyChallengesInstruction.UpdateChallengeTemplateIsActive;
    } & ParsedUpdateChallengeTemplateIsActiveInstruction<TProgram>)
  | ({
      instructionType: PolicyChallengesInstruction.UpdateChallengeTemplateMaxParticipants;
    } & ParsedUpdateChallengeTemplateMaxParticipantsInstruction<TProgram>)
  | ({
      instructionType: PolicyChallengesInstruction.UpdateChallengeTemplateMaximumLoss;
    } & ParsedUpdateChallengeTemplateMaximumLossInstruction<TProgram>)
  | ({
      instructionType: PolicyChallengesInstruction.UpdateChallengeTemplateMinimumTradingDays;
    } & ParsedUpdateChallengeTemplateMinimumTradingDaysInstruction<TProgram>)
  | ({
      instructionType: PolicyChallengesInstruction.UpdateChallengeTemplateProfitTarget;
    } & ParsedUpdateChallengeTemplateProfitTargetInstruction<TProgram>)
  | ({
      instructionType: PolicyChallengesInstruction.Validate;
    } & ParsedValidateInstruction<TProgram>);

export function parsePolicyChallengesInstruction<TProgram extends string>(
  instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>,
): ParsedPolicyChallengesInstruction<TProgram> {
  const instructionType = identifyPolicyChallengesInstruction(instruction);
  switch (instructionType) {
    case PolicyChallengesInstruction.ClaimPayout: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PolicyChallengesInstruction.ClaimPayout,
        ...parseClaimPayoutInstruction(instruction),
      };
    }
    case PolicyChallengesInstruction.CreateChallengeTemplate: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PolicyChallengesInstruction.CreateChallengeTemplate,
        ...parseCreateChallengeTemplateInstruction(instruction),
      };
    }
    case PolicyChallengesInstruction.JoinChallenge: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PolicyChallengesInstruction.JoinChallenge,
        ...parseJoinChallengeInstruction(instruction),
      };
    }
    case PolicyChallengesInstruction.OracleCreateChallenge: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PolicyChallengesInstruction.OracleCreateChallenge,
        ...parseOracleCreateChallengeInstruction(instruction),
      };
    }
    case PolicyChallengesInstruction.OracleCreateOrUpdateChallenge: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType:
          PolicyChallengesInstruction.OracleCreateOrUpdateChallenge,
        ...parseOracleCreateOrUpdateChallengeInstruction(instruction),
      };
    }
    case PolicyChallengesInstruction.UpdateChallenge: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PolicyChallengesInstruction.UpdateChallenge,
        ...parseUpdateChallengeInstruction(instruction),
      };
    }
    case PolicyChallengesInstruction.UpdateChallengeTemplate: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PolicyChallengesInstruction.UpdateChallengeTemplate,
        ...parseUpdateChallengeTemplateInstruction(instruction),
      };
    }
    case PolicyChallengesInstruction.UpdateChallengeTemplateAdmin: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType:
          PolicyChallengesInstruction.UpdateChallengeTemplateAdmin,
        ...parseUpdateChallengeTemplateAdminInstruction(instruction),
      };
    }
    case PolicyChallengesInstruction.UpdateChallengeTemplateDailyDrawdown: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType:
          PolicyChallengesInstruction.UpdateChallengeTemplateDailyDrawdown,
        ...parseUpdateChallengeTemplateDailyDrawdownInstruction(instruction),
      };
    }
    case PolicyChallengesInstruction.UpdateChallengeTemplateEntranceCost: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType:
          PolicyChallengesInstruction.UpdateChallengeTemplateEntranceCost,
        ...parseUpdateChallengeTemplateEntranceCostInstruction(instruction),
      };
    }
    case PolicyChallengesInstruction.UpdateChallengeTemplateEntranceTokenMint: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType:
          PolicyChallengesInstruction.UpdateChallengeTemplateEntranceTokenMint,
        ...parseUpdateChallengeTemplateEntranceTokenMintInstruction(
          instruction,
        ),
      };
    }
    case PolicyChallengesInstruction.UpdateChallengeTemplateIsActive: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType:
          PolicyChallengesInstruction.UpdateChallengeTemplateIsActive,
        ...parseUpdateChallengeTemplateIsActiveInstruction(instruction),
      };
    }
    case PolicyChallengesInstruction.UpdateChallengeTemplateMaxParticipants: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType:
          PolicyChallengesInstruction.UpdateChallengeTemplateMaxParticipants,
        ...parseUpdateChallengeTemplateMaxParticipantsInstruction(instruction),
      };
    }
    case PolicyChallengesInstruction.UpdateChallengeTemplateMaximumLoss: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType:
          PolicyChallengesInstruction.UpdateChallengeTemplateMaximumLoss,
        ...parseUpdateChallengeTemplateMaximumLossInstruction(instruction),
      };
    }
    case PolicyChallengesInstruction.UpdateChallengeTemplateMinimumTradingDays: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType:
          PolicyChallengesInstruction.UpdateChallengeTemplateMinimumTradingDays,
        ...parseUpdateChallengeTemplateMinimumTradingDaysInstruction(
          instruction,
        ),
      };
    }
    case PolicyChallengesInstruction.UpdateChallengeTemplateProfitTarget: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType:
          PolicyChallengesInstruction.UpdateChallengeTemplateProfitTarget,
        ...parseUpdateChallengeTemplateProfitTargetInstruction(instruction),
      };
    }
    case PolicyChallengesInstruction.Validate: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PolicyChallengesInstruction.Validate,
        ...parseValidateInstruction(instruction),
      };
    }
    default:
      throw new Error(
        `Unrecognized instruction type: ${instructionType as string}`,
      );
  }
}
