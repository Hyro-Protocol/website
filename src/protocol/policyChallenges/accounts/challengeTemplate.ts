/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBooleanDecoder,
  getBooleanEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU16Decoder,
  getU16Encoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type Account,
  type Address,
  type EncodedAccount,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  getPercentDecoder,
  getPercentEncoder,
  getSmallScalarDecoder,
  getSmallScalarEncoder,
  getStageTypeDecoder,
  getStageTypeEncoder,
  type Percent,
  type PercentArgs,
  type SmallScalar,
  type SmallScalarArgs,
  type StageType,
  type StageTypeArgs,
} from '../types';

export const CHALLENGE_TEMPLATE_DISCRIMINATOR = new Uint8Array([
  83, 2, 108, 68, 110, 219, 175, 21,
]);

export function getChallengeTemplateDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    CHALLENGE_TEMPLATE_DISCRIMINATOR
  );
}

export type ChallengeTemplate = {
  discriminator: ReadonlyUint8Array;
  stageId: number;
  stageSequence: number;
  stageType: StageType;
  startingDeposit: bigint;
  admin: Address;
  entranceCost: bigint;
  entranceTokenMint: Address;
  minimumTradingDays: SmallScalar;
  dailyDrawdown: Percent;
  maximumLoss: Percent;
  profitTarget: Percent;
  maxParticipants: SmallScalar;
  participants: SmallScalar;
  totalPool: bigint;
  isActive: boolean;
};

export type ChallengeTemplateArgs = {
  stageId: number;
  stageSequence: number;
  stageType: StageTypeArgs;
  startingDeposit: number | bigint;
  admin: Address;
  entranceCost: number | bigint;
  entranceTokenMint: Address;
  minimumTradingDays: SmallScalarArgs;
  dailyDrawdown: PercentArgs;
  maximumLoss: PercentArgs;
  profitTarget: PercentArgs;
  maxParticipants: SmallScalarArgs;
  participants: SmallScalarArgs;
  totalPool: number | bigint;
  isActive: boolean;
};

/** Gets the encoder for {@link ChallengeTemplateArgs} account data. */
export function getChallengeTemplateEncoder(): FixedSizeEncoder<ChallengeTemplateArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['stageId', getU16Encoder()],
      ['stageSequence', getU8Encoder()],
      ['stageType', getStageTypeEncoder()],
      ['startingDeposit', getU64Encoder()],
      ['admin', getAddressEncoder()],
      ['entranceCost', getU64Encoder()],
      ['entranceTokenMint', getAddressEncoder()],
      ['minimumTradingDays', getSmallScalarEncoder()],
      ['dailyDrawdown', getPercentEncoder()],
      ['maximumLoss', getPercentEncoder()],
      ['profitTarget', getPercentEncoder()],
      ['maxParticipants', getSmallScalarEncoder()],
      ['participants', getSmallScalarEncoder()],
      ['totalPool', getU64Encoder()],
      ['isActive', getBooleanEncoder()],
    ]),
    (value) => ({ ...value, discriminator: CHALLENGE_TEMPLATE_DISCRIMINATOR })
  );
}

/** Gets the decoder for {@link ChallengeTemplate} account data. */
export function getChallengeTemplateDecoder(): FixedSizeDecoder<ChallengeTemplate> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['stageId', getU16Decoder()],
    ['stageSequence', getU8Decoder()],
    ['stageType', getStageTypeDecoder()],
    ['startingDeposit', getU64Decoder()],
    ['admin', getAddressDecoder()],
    ['entranceCost', getU64Decoder()],
    ['entranceTokenMint', getAddressDecoder()],
    ['minimumTradingDays', getSmallScalarDecoder()],
    ['dailyDrawdown', getPercentDecoder()],
    ['maximumLoss', getPercentDecoder()],
    ['profitTarget', getPercentDecoder()],
    ['maxParticipants', getSmallScalarDecoder()],
    ['participants', getSmallScalarDecoder()],
    ['totalPool', getU64Decoder()],
    ['isActive', getBooleanDecoder()],
  ]);
}

/** Gets the codec for {@link ChallengeTemplate} account data. */
export function getChallengeTemplateCodec(): FixedSizeCodec<
  ChallengeTemplateArgs,
  ChallengeTemplate
> {
  return combineCodec(
    getChallengeTemplateEncoder(),
    getChallengeTemplateDecoder()
  );
}

export function decodeChallengeTemplate<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>
): Account<ChallengeTemplate, TAddress>;
export function decodeChallengeTemplate<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<ChallengeTemplate, TAddress>;
export function decodeChallengeTemplate<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
):
  | Account<ChallengeTemplate, TAddress>
  | MaybeAccount<ChallengeTemplate, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getChallengeTemplateDecoder()
  );
}

export async function fetchChallengeTemplate<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<Account<ChallengeTemplate, TAddress>> {
  const maybeAccount = await fetchMaybeChallengeTemplate(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeChallengeTemplate<
  TAddress extends string = string,
>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<MaybeAccount<ChallengeTemplate, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeChallengeTemplate(maybeAccount);
}

export async function fetchAllChallengeTemplate(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<Account<ChallengeTemplate>[]> {
  const maybeAccounts = await fetchAllMaybeChallengeTemplate(
    rpc,
    addresses,
    config
  );
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeChallengeTemplate(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<MaybeAccount<ChallengeTemplate>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) =>
    decodeChallengeTemplate(maybeAccount)
  );
}

export function getChallengeTemplateSize(): number {
  return 113;
}
