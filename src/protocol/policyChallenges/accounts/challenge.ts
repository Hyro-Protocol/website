/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  addDecoderSizePrefix,
  addEncoderSizePrefix,
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU16Decoder,
  getU16Encoder,
  getU32Decoder,
  getU32Encoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  getUtf8Decoder,
  getUtf8Encoder,
  transformEncoder,
  type Account,
  type Address,
  type Codec,
  type Decoder,
  type EncodedAccount,
  type Encoder,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  getChallengeStatusDecoder,
  getChallengeStatusEncoder,
  getDailyDrawdownDecoder,
  getDailyDrawdownEncoder,
  getMaximumLossDecoder,
  getMaximumLossEncoder,
  getProfitTargetDecoder,
  getProfitTargetEncoder,
  getStageTypeDecoder,
  getStageTypeEncoder,
  getTradingDaysDecoder,
  getTradingDaysEncoder,
  type ChallengeStatus,
  type ChallengeStatusArgs,
  type DailyDrawdown,
  type DailyDrawdownArgs,
  type MaximumLoss,
  type MaximumLossArgs,
  type ProfitTarget,
  type ProfitTargetArgs,
  type StageType,
  type StageTypeArgs,
  type TradingDays,
  type TradingDaysArgs,
} from '../types';

export const CHALLENGE_DISCRIMINATOR = new Uint8Array([
  119, 250, 161, 121, 119, 81, 22, 208,
]);

export function getChallengeDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(CHALLENGE_DISCRIMINATOR);
}

export type Challenge = {
  discriminator: ReadonlyUint8Array;
  challengeId: string;
  stageId: number;
  stageSequence: number;
  stageType: StageType;
  effectiveFrom: bigint;
  startingBalance: bigint;
  latestBalance: bigint;
  profitTarget: ProfitTarget;
  tradingDays: TradingDays;
  maximumLoss: MaximumLoss;
  dailyDrawdown: DailyDrawdown;
  user: Address;
  status: ChallengeStatus;
  payout: bigint;
  createdAt: bigint;
  updatedAt: bigint;
};

export type ChallengeArgs = {
  challengeId: string;
  stageId: number;
  stageSequence: number;
  stageType: StageTypeArgs;
  effectiveFrom: number | bigint;
  startingBalance: number | bigint;
  latestBalance: number | bigint;
  profitTarget: ProfitTargetArgs;
  tradingDays: TradingDaysArgs;
  maximumLoss: MaximumLossArgs;
  dailyDrawdown: DailyDrawdownArgs;
  user: Address;
  status: ChallengeStatusArgs;
  payout: number | bigint;
  createdAt: number | bigint;
  updatedAt: number | bigint;
};

/** Gets the encoder for {@link ChallengeArgs} account data. */
export function getChallengeEncoder(): Encoder<ChallengeArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['challengeId', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
      ['stageId', getU16Encoder()],
      ['stageSequence', getU8Encoder()],
      ['stageType', getStageTypeEncoder()],
      ['effectiveFrom', getU64Encoder()],
      ['startingBalance', getU64Encoder()],
      ['latestBalance', getU64Encoder()],
      ['profitTarget', getProfitTargetEncoder()],
      ['tradingDays', getTradingDaysEncoder()],
      ['maximumLoss', getMaximumLossEncoder()],
      ['dailyDrawdown', getDailyDrawdownEncoder()],
      ['user', getAddressEncoder()],
      ['status', getChallengeStatusEncoder()],
      ['payout', getU64Encoder()],
      ['createdAt', getU64Encoder()],
      ['updatedAt', getU64Encoder()],
    ]),
    (value) => ({ ...value, discriminator: CHALLENGE_DISCRIMINATOR })
  );
}

/** Gets the decoder for {@link Challenge} account data. */
export function getChallengeDecoder(): Decoder<Challenge> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['challengeId', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ['stageId', getU16Decoder()],
    ['stageSequence', getU8Decoder()],
    ['stageType', getStageTypeDecoder()],
    ['effectiveFrom', getU64Decoder()],
    ['startingBalance', getU64Decoder()],
    ['latestBalance', getU64Decoder()],
    ['profitTarget', getProfitTargetDecoder()],
    ['tradingDays', getTradingDaysDecoder()],
    ['maximumLoss', getMaximumLossDecoder()],
    ['dailyDrawdown', getDailyDrawdownDecoder()],
    ['user', getAddressDecoder()],
    ['status', getChallengeStatusDecoder()],
    ['payout', getU64Decoder()],
    ['createdAt', getU64Decoder()],
    ['updatedAt', getU64Decoder()],
  ]);
}

/** Gets the codec for {@link Challenge} account data. */
export function getChallengeCodec(): Codec<ChallengeArgs, Challenge> {
  return combineCodec(getChallengeEncoder(), getChallengeDecoder());
}

export function decodeChallenge<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>
): Account<Challenge, TAddress>;
export function decodeChallenge<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<Challenge, TAddress>;
export function decodeChallenge<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<Challenge, TAddress> | MaybeAccount<Challenge, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getChallengeDecoder()
  );
}

export async function fetchChallenge<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<Account<Challenge, TAddress>> {
  const maybeAccount = await fetchMaybeChallenge(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeChallenge<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<MaybeAccount<Challenge, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeChallenge(maybeAccount);
}

export async function fetchAllChallenge(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<Account<Challenge>[]> {
  const maybeAccounts = await fetchAllMaybeChallenge(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeChallenge(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<MaybeAccount<Challenge>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeChallenge(maybeAccount));
}
