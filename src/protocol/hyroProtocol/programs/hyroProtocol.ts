/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertIsInstructionWithAccounts,
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type Instruction,
  type InstructionWithData,
  type ReadonlyUint8Array,
} from "@solana/kit";
import {
  parseClaimFeesInstruction,
  parseCreateTxInstruction,
  parseDepositAssetsInstruction,
  parseExecuteTxInstruction,
  parseInitializeManagerRegistryInstruction,
  parseInitializeVaultInstruction,
  parseIssueChildVaultInstruction,
  parsePingInstruction,
  parseRecalculateBalanceInstruction,
  parseRedeemSharesInstruction,
  parseRegisterManagerInstruction,
  parseReportOnFundsInstruction,
  parseReturnFundsInstruction,
  parseUseFundsInstruction,
  parseVerifyManagerInstruction,
  type ParsedClaimFeesInstruction,
  type ParsedCreateTxInstruction,
  type ParsedDepositAssetsInstruction,
  type ParsedExecuteTxInstruction,
  type ParsedInitializeManagerRegistryInstruction,
  type ParsedInitializeVaultInstruction,
  type ParsedIssueChildVaultInstruction,
  type ParsedPingInstruction,
  type ParsedRecalculateBalanceInstruction,
  type ParsedRedeemSharesInstruction,
  type ParsedRegisterManagerInstruction,
  type ParsedReportOnFundsInstruction,
  type ParsedReturnFundsInstruction,
  type ParsedUseFundsInstruction,
  type ParsedVerifyManagerInstruction,
} from "../instructions";

export const HYRO_PROTOCOL_PROGRAM_ADDRESS =
  "7gx2mxou2JwuBNiDhfPeXf8EVK8DUGnXPLKdiyYKT3NL" as Address<"7gx2mxou2JwuBNiDhfPeXf8EVK8DUGnXPLKdiyYKT3NL">;

export enum HyroProtocolAccount {
  ManagerProfile,
  ManagerRegistry,
  Transaction,
  Vault,
}

export function identifyHyroProtocolAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): HyroProtocolAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([135, 12, 238, 243, 236, 32, 123, 52]),
      ),
      0,
    )
  ) {
    return HyroProtocolAccount.ManagerProfile;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([181, 78, 54, 100, 122, 86, 63, 114]),
      ),
      0,
    )
  ) {
    return HyroProtocolAccount.ManagerRegistry;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([11, 24, 174, 129, 203, 117, 242, 23]),
      ),
      0,
    )
  ) {
    return HyroProtocolAccount.Transaction;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([211, 8, 232, 43, 2, 152, 117, 119]),
      ),
      0,
    )
  ) {
    return HyroProtocolAccount.Vault;
  }
  throw new Error(
    "The provided account could not be identified as a hyroProtocol account.",
  );
}

export enum HyroProtocolInstruction {
  ClaimFees,
  CreateTx,
  DepositAssets,
  ExecuteTx,
  InitializeManagerRegistry,
  InitializeVault,
  IssueChildVault,
  Ping,
  RecalculateBalance,
  RedeemShares,
  RegisterManager,
  ReportOnFunds,
  ReturnFunds,
  UseFunds,
  VerifyManager,
}

export function identifyHyroProtocolInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): HyroProtocolInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([82, 251, 233, 156, 12, 52, 184, 202]),
      ),
      0,
    )
  ) {
    return HyroProtocolInstruction.ClaimFees;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([97, 223, 80, 153, 55, 13, 155, 12]),
      ),
      0,
    )
  ) {
    return HyroProtocolInstruction.CreateTx;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([8, 21, 152, 34, 223, 94, 7, 176]),
      ),
      0,
    )
  ) {
    return HyroProtocolInstruction.DepositAssets;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([249, 17, 145, 23, 12, 252, 17, 41]),
      ),
      0,
    )
  ) {
    return HyroProtocolInstruction.ExecuteTx;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([45, 38, 8, 215, 181, 198, 110, 202]),
      ),
      0,
    )
  ) {
    return HyroProtocolInstruction.InitializeManagerRegistry;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([48, 191, 163, 44, 71, 129, 63, 164]),
      ),
      0,
    )
  ) {
    return HyroProtocolInstruction.InitializeVault;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([77, 93, 95, 1, 227, 206, 201, 173]),
      ),
      0,
    )
  ) {
    return HyroProtocolInstruction.IssueChildVault;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([173, 0, 94, 236, 73, 133, 225, 153]),
      ),
      0,
    )
  ) {
    return HyroProtocolInstruction.Ping;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([119, 21, 228, 154, 19, 193, 246, 8]),
      ),
      0,
    )
  ) {
    return HyroProtocolInstruction.RecalculateBalance;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([239, 154, 224, 89, 240, 196, 42, 187]),
      ),
      0,
    )
  ) {
    return HyroProtocolInstruction.RedeemShares;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([104, 14, 206, 198, 57, 194, 90, 109]),
      ),
      0,
    )
  ) {
    return HyroProtocolInstruction.RegisterManager;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([106, 224, 151, 62, 55, 104, 47, 191]),
      ),
      0,
    )
  ) {
    return HyroProtocolInstruction.ReportOnFunds;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([220, 104, 119, 202, 186, 1, 45, 90]),
      ),
      0,
    )
  ) {
    return HyroProtocolInstruction.ReturnFunds;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([225, 89, 79, 83, 153, 141, 236, 230]),
      ),
      0,
    )
  ) {
    return HyroProtocolInstruction.UseFunds;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([61, 121, 49, 235, 68, 94, 106, 30]),
      ),
      0,
    )
  ) {
    return HyroProtocolInstruction.VerifyManager;
  }
  throw new Error(
    "The provided instruction could not be identified as a hyroProtocol instruction.",
  );
}

export type ParsedHyroProtocolInstruction<
  TProgram extends string = "7gx2mxou2JwuBNiDhfPeXf8EVK8DUGnXPLKdiyYKT3NL",
> =
  | ({
      instructionType: HyroProtocolInstruction.ClaimFees;
    } & ParsedClaimFeesInstruction<TProgram>)
  | ({
      instructionType: HyroProtocolInstruction.CreateTx;
    } & ParsedCreateTxInstruction<TProgram>)
  | ({
      instructionType: HyroProtocolInstruction.DepositAssets;
    } & ParsedDepositAssetsInstruction<TProgram>)
  | ({
      instructionType: HyroProtocolInstruction.ExecuteTx;
    } & ParsedExecuteTxInstruction<TProgram>)
  | ({
      instructionType: HyroProtocolInstruction.InitializeManagerRegistry;
    } & ParsedInitializeManagerRegistryInstruction<TProgram>)
  | ({
      instructionType: HyroProtocolInstruction.InitializeVault;
    } & ParsedInitializeVaultInstruction<TProgram>)
  | ({
      instructionType: HyroProtocolInstruction.IssueChildVault;
    } & ParsedIssueChildVaultInstruction<TProgram>)
  | ({
      instructionType: HyroProtocolInstruction.Ping;
    } & ParsedPingInstruction<TProgram>)
  | ({
      instructionType: HyroProtocolInstruction.RecalculateBalance;
    } & ParsedRecalculateBalanceInstruction<TProgram>)
  | ({
      instructionType: HyroProtocolInstruction.RedeemShares;
    } & ParsedRedeemSharesInstruction<TProgram>)
  | ({
      instructionType: HyroProtocolInstruction.RegisterManager;
    } & ParsedRegisterManagerInstruction<TProgram>)
  | ({
      instructionType: HyroProtocolInstruction.ReportOnFunds;
    } & ParsedReportOnFundsInstruction<TProgram>)
  | ({
      instructionType: HyroProtocolInstruction.ReturnFunds;
    } & ParsedReturnFundsInstruction<TProgram>)
  | ({
      instructionType: HyroProtocolInstruction.UseFunds;
    } & ParsedUseFundsInstruction<TProgram>)
  | ({
      instructionType: HyroProtocolInstruction.VerifyManager;
    } & ParsedVerifyManagerInstruction<TProgram>);

export function parseHyroProtocolInstruction<TProgram extends string>(
  instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>,
): ParsedHyroProtocolInstruction<TProgram> {
  const instructionType = identifyHyroProtocolInstruction(instruction);
  switch (instructionType) {
    case HyroProtocolInstruction.ClaimFees: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: HyroProtocolInstruction.ClaimFees,
        ...parseClaimFeesInstruction(instruction),
      };
    }
    case HyroProtocolInstruction.CreateTx: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: HyroProtocolInstruction.CreateTx,
        ...parseCreateTxInstruction(instruction),
      };
    }
    case HyroProtocolInstruction.DepositAssets: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: HyroProtocolInstruction.DepositAssets,
        ...parseDepositAssetsInstruction(instruction),
      };
    }
    case HyroProtocolInstruction.ExecuteTx: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: HyroProtocolInstruction.ExecuteTx,
        ...parseExecuteTxInstruction(instruction),
      };
    }
    case HyroProtocolInstruction.InitializeManagerRegistry: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: HyroProtocolInstruction.InitializeManagerRegistry,
        ...parseInitializeManagerRegistryInstruction(instruction),
      };
    }
    case HyroProtocolInstruction.InitializeVault: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: HyroProtocolInstruction.InitializeVault,
        ...parseInitializeVaultInstruction(instruction),
      };
    }
    case HyroProtocolInstruction.IssueChildVault: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: HyroProtocolInstruction.IssueChildVault,
        ...parseIssueChildVaultInstruction(instruction),
      };
    }
    case HyroProtocolInstruction.Ping: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: HyroProtocolInstruction.Ping,
        ...parsePingInstruction(instruction),
      };
    }
    case HyroProtocolInstruction.RecalculateBalance: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: HyroProtocolInstruction.RecalculateBalance,
        ...parseRecalculateBalanceInstruction(instruction),
      };
    }
    case HyroProtocolInstruction.RedeemShares: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: HyroProtocolInstruction.RedeemShares,
        ...parseRedeemSharesInstruction(instruction),
      };
    }
    case HyroProtocolInstruction.RegisterManager: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: HyroProtocolInstruction.RegisterManager,
        ...parseRegisterManagerInstruction(instruction),
      };
    }
    case HyroProtocolInstruction.ReportOnFunds: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: HyroProtocolInstruction.ReportOnFunds,
        ...parseReportOnFundsInstruction(instruction),
      };
    }
    case HyroProtocolInstruction.ReturnFunds: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: HyroProtocolInstruction.ReturnFunds,
        ...parseReturnFundsInstruction(instruction),
      };
    }
    case HyroProtocolInstruction.UseFunds: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: HyroProtocolInstruction.UseFunds,
        ...parseUseFundsInstruction(instruction),
      };
    }
    case HyroProtocolInstruction.VerifyManager: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: HyroProtocolInstruction.VerifyManager,
        ...parseVerifyManagerInstruction(instruction),
      };
    }
    default:
      throw new Error(
        `Unrecognized instruction type: ${instructionType as string}`,
      );
  }
}
