/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertIsInstructionWithAccounts,
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type Instruction,
  type InstructionWithData,
  type ReadonlyUint8Array,
} from "@solana/kit";
import {
  parseCalculateFeesInstruction,
  parseInitializeInstruction,
  parseResetTimestampsInstruction,
  parseUpdateConfigInstruction,
  parseUpdateFractionConfigInstruction,
  parseUpdateHighWaterMarkInstruction,
  parseUpdateTimeBasedConfigInstruction,
  type ParsedCalculateFeesInstruction,
  type ParsedInitializeInstruction,
  type ParsedResetTimestampsInstruction,
  type ParsedUpdateConfigInstruction,
  type ParsedUpdateFractionConfigInstruction,
  type ParsedUpdateHighWaterMarkInstruction,
  type ParsedUpdateTimeBasedConfigInstruction,
} from "../instructions";

export const FEE_COLLECTION_ALL_IN_ONE_PROGRAM_ADDRESS =
  "DzAecV65f1Cuyr1h5F2khGThE3aQEB5ccJVCRRZSoQZT" as Address<"DzAecV65f1Cuyr1h5F2khGThE3aQEB5ccJVCRRZSoQZT">;

export enum FeeCollectionAllInOneAccount {
  VaultAllInOneConfig,
}

export function identifyFeeCollectionAllInOneAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): FeeCollectionAllInOneAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([124, 88, 126, 126, 39, 118, 51, 134]),
      ),
      0,
    )
  ) {
    return FeeCollectionAllInOneAccount.VaultAllInOneConfig;
  }
  throw new Error(
    "The provided account could not be identified as a feeCollectionAllInOne account.",
  );
}

export enum FeeCollectionAllInOneInstruction {
  CalculateFees,
  Initialize,
  ResetTimestamps,
  UpdateConfig,
  UpdateFractionConfig,
  UpdateHighWaterMark,
  UpdateTimeBasedConfig,
}

export function identifyFeeCollectionAllInOneInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): FeeCollectionAllInOneInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([140, 235, 78, 9, 249, 8, 129, 101]),
      ),
      0,
    )
  ) {
    return FeeCollectionAllInOneInstruction.CalculateFees;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([175, 175, 109, 31, 13, 152, 155, 237]),
      ),
      0,
    )
  ) {
    return FeeCollectionAllInOneInstruction.Initialize;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([145, 21, 122, 247, 201, 112, 88, 236]),
      ),
      0,
    )
  ) {
    return FeeCollectionAllInOneInstruction.ResetTimestamps;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([29, 158, 252, 191, 10, 83, 219, 99]),
      ),
      0,
    )
  ) {
    return FeeCollectionAllInOneInstruction.UpdateConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([251, 44, 246, 37, 62, 95, 147, 171]),
      ),
      0,
    )
  ) {
    return FeeCollectionAllInOneInstruction.UpdateFractionConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([68, 148, 239, 216, 150, 14, 205, 238]),
      ),
      0,
    )
  ) {
    return FeeCollectionAllInOneInstruction.UpdateHighWaterMark;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([1, 170, 161, 15, 4, 42, 89, 118]),
      ),
      0,
    )
  ) {
    return FeeCollectionAllInOneInstruction.UpdateTimeBasedConfig;
  }
  throw new Error(
    "The provided instruction could not be identified as a feeCollectionAllInOne instruction.",
  );
}

export type ParsedFeeCollectionAllInOneInstruction<
  TProgram extends string = "DzAecV65f1Cuyr1h5F2khGThE3aQEB5ccJVCRRZSoQZT",
> =
  | ({
      instructionType: FeeCollectionAllInOneInstruction.CalculateFees;
    } & ParsedCalculateFeesInstruction<TProgram>)
  | ({
      instructionType: FeeCollectionAllInOneInstruction.Initialize;
    } & ParsedInitializeInstruction<TProgram>)
  | ({
      instructionType: FeeCollectionAllInOneInstruction.ResetTimestamps;
    } & ParsedResetTimestampsInstruction<TProgram>)
  | ({
      instructionType: FeeCollectionAllInOneInstruction.UpdateConfig;
    } & ParsedUpdateConfigInstruction<TProgram>)
  | ({
      instructionType: FeeCollectionAllInOneInstruction.UpdateFractionConfig;
    } & ParsedUpdateFractionConfigInstruction<TProgram>)
  | ({
      instructionType: FeeCollectionAllInOneInstruction.UpdateHighWaterMark;
    } & ParsedUpdateHighWaterMarkInstruction<TProgram>)
  | ({
      instructionType: FeeCollectionAllInOneInstruction.UpdateTimeBasedConfig;
    } & ParsedUpdateTimeBasedConfigInstruction<TProgram>);

export function parseFeeCollectionAllInOneInstruction<TProgram extends string>(
  instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>,
): ParsedFeeCollectionAllInOneInstruction<TProgram> {
  const instructionType = identifyFeeCollectionAllInOneInstruction(instruction);
  switch (instructionType) {
    case FeeCollectionAllInOneInstruction.CalculateFees: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: FeeCollectionAllInOneInstruction.CalculateFees,
        ...parseCalculateFeesInstruction(instruction),
      };
    }
    case FeeCollectionAllInOneInstruction.Initialize: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: FeeCollectionAllInOneInstruction.Initialize,
        ...parseInitializeInstruction(instruction),
      };
    }
    case FeeCollectionAllInOneInstruction.ResetTimestamps: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: FeeCollectionAllInOneInstruction.ResetTimestamps,
        ...parseResetTimestampsInstruction(instruction),
      };
    }
    case FeeCollectionAllInOneInstruction.UpdateConfig: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: FeeCollectionAllInOneInstruction.UpdateConfig,
        ...parseUpdateConfigInstruction(instruction),
      };
    }
    case FeeCollectionAllInOneInstruction.UpdateFractionConfig: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: FeeCollectionAllInOneInstruction.UpdateFractionConfig,
        ...parseUpdateFractionConfigInstruction(instruction),
      };
    }
    case FeeCollectionAllInOneInstruction.UpdateHighWaterMark: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: FeeCollectionAllInOneInstruction.UpdateHighWaterMark,
        ...parseUpdateHighWaterMarkInstruction(instruction),
      };
    }
    case FeeCollectionAllInOneInstruction.UpdateTimeBasedConfig: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: FeeCollectionAllInOneInstruction.UpdateTimeBasedConfig,
        ...parseUpdateTimeBasedConfigInstruction(instruction),
      };
    }
    default:
      throw new Error(
        `Unrecognized instruction type: ${instructionType as string}`,
      );
  }
}
